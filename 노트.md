### 시간복잡도

- 평균 시간 복잡도
  - 랜덤한 입력
- 최악 시간 복잡도
  - 최악의 경우를 만들어내는 입력

### Big O notation (점근 표기법)

- 함수의 증가 양상 표기법

- 입력의 크기와 시간의 비례를 의미
- 계수는 무시



### Linked List (연결 리스트)

- 추상적 자료구조
  - Data
    - 정수, 문자열, 레코드
  - A set of operations
    - 삽입, 삭제, 순회
    - 정렬, 탐색 등
- 장점
  - 삽입과 삭제가 자유로움



### Stack

- LIFO(후입선출)의 특징을 가지는 선형 자료구조
- Stack underflow / stack overflow
- 스택의 연산
  - size() - 원소의 개수
  - isEmpty() - 비어있는지 여부
  - push(x) - x를 스택에 추가
  - pop() - 스택의 맨 위의 원소를 제거 후 반환
  - top() - 스택의 맨 위의 원소를 반환
- 관련 문제
  - 수식의 괄호 유효성 검사
  - 중위/후위 표기법



### Queue

- 대기열이라는 뜻

- FIFO(선입선출)의 특징을 가지는 선형 자료구조
- 큐의 연산
  - size() - 원소의 개수
  - isEmpty() - 비어있는지 여부
  - enqueue(x) - x를 큐에 추가
  - dequeue() - 큐의 맨 처음 원소를 제거 후 반환
  - front() - 큐의 맨 처음 원소를 반환
  - isFull() - 원형 큐의 경우 큐가 다 찼는지 확인
- 큐의 활용
  - 데이터 생성과 이용이 비동기적으로 이루어지는 경우
  - 데이터 생성이 여러 곳에서 이루어지는 경우
  - 데이터 이용이 여러 곳에서 이루어지는 경우
  - 데이터 생성과 이용이 여러 곳에서 이루어지는 경우
  - 데이터를 이용하여 새로운 데이터를 생성하고 나중에 그 데이터를 또 처리해야 하는 경우 



### Circular Queue(원형 큐)

- 정해진 개수의 저장공간을 빙 돌려가며 이용
- 큐가 가득차면 더이상 원소를 넣을 수 없음(큐 길이를 기억하고 있어야 함)
- 배열로 구현



### Priority Queue(우선순위 큐)

- 큐가 FIFO방식을 따르지 않고 원소들의 우선순위에 따라 큐에서 빠져나오는 방식

- ex) 운영체제의 CPU 스케쥴러

- 구현 방식

  1. Enqueue()할 때 우선순위 유지
  2. Dequeue()할 때 우선순위 높은 것을 선택 

  - 1번이 효율적
  - Enqueue() 구현시 배열이 공간은 효율적이지만 연결리스트가 시간은 더 빠름



### Tree

- 2차원의 자료구조
- node / edge를 이용하여 데이터의 배치 형태를 추상화한 자료 구조
- root / internal / leaf node
- 노드의 parent / child / sibling / ancestor / descendant 관계
  - root 노드를 제외한 모든 노드는 parent 노드를 가지고 있음
- 노드의 level 
  - root로부터 특정노드까지 도달하는데에 여러 edge를 통과하는 하나의 길이 생기는데 그 때 통과하는 edge의 개수

- 트리의 height(==depth) 
  - 트리의 최대 level + 1
- subtree(부분트리)
  - 특정 노드 한개로부터 그 아래의 모든 decendant
- degree(차수)
  - child(혹은 subtree)의 개수
  - parent 노드는 항상 하나이지만 child 노드는 여러개가 될 수 있음
  - degree가 0인 노드 == leaf node

#### Binary Tree(이진트리)

- 모든 노드의 degree가 2 이하인 트리
- 재귀적으로 정의할 수 있음
- empty tree 이거나 루트 노드 + 왼쪽 이진 서브트리 + 오른쪽 이진 서브트리

#### Full Binary Tree(포화 이진 트리)

- 모든 레벨에서 노드들이 채워져있는 이진 트리
- 높이가 k이고 노드의 개수는 2^k -1개

#### Complete Binary Tree(완전 이진 트리)

- 높이가 k일 때 레벨 k-2까지는 모든 노드가 2개의 자식을 가진 Full Binary Tree이고 레벨 k-1까지는 왼쪽부터 노드가 순차적으로 채워져있는 이진 트리


#### 이진 탐색트리의 단점

- 한쪽으로만 치우치게 되는 경우 선형탐색과 같은 O(n)의 시간복잡도를 가짐	
- AVL tree 혹은 Red-black tree 같은 대안이 있



### Heap

- 이진트리의 한 종류
- 이진 힙(binary heap)이라고도 부름
- root 노드가 항상 최대값(max heap) 혹은 최솟값(min heap)을 가짐
- 완전 이진 트리 

#### 이진 탐색 트리와의 비교

|                                                     | 이진탐색트리 | Heap           |
| --------------------------------------------------- | ------------ | -------------- |
| 원소들이 완전히 크기순으로 정렬되어 있는가?         | O            | X              |
| 특정 키 값을 가지는 원소를 빠르게 검색할 수 있는가? | O            | X              |
| 부가의 제약 조건은 어떤 것인가?                     | X            | 완전 이진 트리 |

#### 힙의 응용

- 우선 순위 큐
- 힙 정렬 (heap sort)
  - 정렬되지 않은 원소들을 아무 순서로나 최대 힙에 삽입 - O(logn)
  - 삽입이 끝나면 힙이 비게 될 때까지 하나씩 삭제 - O(logn)
  - 전체는 O(nlogn)
